<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>DOM + BOM | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.childNodes     元素.childNodes : 只读 属性 子节点列表集合  标准下：包含了文本和元素类型的节点，也会包含非法嵌套的子节点 非标准下：只包含元素类型的节点，ie7以下不会包含非法嵌套子节点 childNodes只包含一级子节点，不包含后辈孙级以下的节点  DOM节点的类型有很多种    12种 元素.nodeType : 只读 属性 当前元素的节点类型 元素节点">
<meta property="og:type" content="article">
<meta property="og:title" content="DOM + BOM">
<meta property="og:url" content="http://yoursite.com/2018/03/20/DOM + BOM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.childNodes     元素.childNodes : 只读 属性 子节点列表集合  标准下：包含了文本和元素类型的节点，也会包含非法嵌套的子节点 非标准下：只包含元素类型的节点，ie7以下不会包含非法嵌套子节点 childNodes只包含一级子节点，不包含后辈孙级以下的节点  DOM节点的类型有很多种    12种 元素.nodeType : 只读 属性 当前元素的节点类型 元素节点">
<meta property="og:updated_time" content="2018-03-20T05:01:03.050Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DOM + BOM">
<meta name="twitter:description" content="1.childNodes     元素.childNodes : 只读 属性 子节点列表集合  标准下：包含了文本和元素类型的节点，也会包含非法嵌套的子节点 非标准下：只包含元素类型的节点，ie7以下不会包含非法嵌套子节点 childNodes只包含一级子节点，不包含后辈孙级以下的节点  DOM节点的类型有很多种    12种 元素.nodeType : 只读 属性 当前元素的节点类型 元素节点">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-DOM + BOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/DOM + BOM/" class="article-date">
  <time datetime="2018-03-20T04:59:58.011Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      DOM + BOM
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.childNodes     元素.childNodes : 只读 属性 子节点列表集合</p>
<p> 标准下：包含了文本和元素类型的节点，也会包含非法嵌套的子节点</p>
<p>非标准下：只包含元素类型的节点，ie7以下不会包含非法嵌套子节点</p>
<p>childNodes只包含一级子节点，不包含后辈孙级以下的节点</p>
<p> DOM节点的类型有很多种    12种</p>
<p>元素.nodeType : 只读 属性 当前元素的节点类型</p>
<pre><code>元素节点    :    1
属性节点    :    2
文本节点  :    3

元素.attributes : 只读 属性 属性列表集合
</code></pre><p>childNodes  解决兼容性问题</p>
<pre><code> if ( 父级元素（oUl）.childNodes[i].nodeType == 1 ) {
    oUl.childNodes[i].style.background = &apos;red&apos;;
}
</code></pre><p>2.children(√)       元素.children : 只读 属性 子节点列表集合</p>
<p>标准下：只包含元素类型的节点    算</p><p></p><p></p>
<p>非标准下：只包含元素类型的节点    不算</p><p></p><p></p>
<pre><code>for (var i=0; i&lt;oUl.children.length; i++) {
          oUl.children[i].style.background = &apos;red&apos;;
          }      
</code></pre><p>3.firstChild        元素.firstChild : 只读 属性 第一个子节点</p>
<p>  标准下：firstChild会包含文本类型的节点</p>
<p> 非标准下：只包含元素节点</p>
<p>4.firstElementChild<br>    元素.firstElementChild : 只读 属性 标准下获取第一个元素类型的子节点<br>找第一个子节点  解决兼容性问题</p>
<pre><code>var oFirst = oUl.firstElementChild || oUl.firstChild;
oFirst.style.background = &apos;red&apos;;
元素.lastChild || 元素.lastElementChild        最后一个子节点
var oLast = oUl.lastElementChild || oUl.lastChild; 
oLast.style.background = &apos;yellow&apos;;
元素.nextSibling || 元素.nextElementSibling    下一个兄弟节点
var oNext = oFirst.nextElementSibling || oFirst.nextSibling;
 oNext.style.background = &apos;blue&apos;;
 元素.previousSibling || 元素.previousElementSibling    上一个兄弟节点
  var oPrev = oLast.previousElementSibling || oLast.previousSibling;
   oPrev.style.background = &apos;orange&apos;;
</code></pre><p> 找第一个子节点常用（√）<br>                      if ( oUl.children[0] ) {<br>                           oUl.children[0].style.background = ‘red’;<br>                         } else {<br>                         alert( ‘没有子节点可以设置’ );<br>                      }</p>
<p>5.parentNode （√）  元素.parentNode : 只读 属性 当前节点的父级节点</p>
<p>6.offsetParent      元素.offsetParent : 只读 属性 离当前元素最近的一个有定位属性的父节点        </p>
<pre><code>如果没有定位父级，默认是body
ie7以下，如果当前元素没有定位默认是body，如果有定位则是html
ie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会被指向到这个触发了layout特性的父节点上
</code></pre><p>7.offsetLeft[Top]    元素.offsetLeft[Top] : 只读 属性 当前元素到定位父级的距离（偏移值）        </p>
<p>到当前元素的offsetParent的距离</p>
<p> 如果没有定位父级</p>
<pre><code>offsetParent -&gt; body
offsetLeft -&gt; html
</code></pre><p>如果有定位父级            </p>
<pre><code>ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离
如果自己有定位，那么就是到定位父级的距离
其他：到定位父级的距离
</code></pre><p>获得  offsetLeft[Top] 封装函数       </p>
<pre><code>function getPos(obj) {               
               var pos = {left:0, top:0};
                while (obj) {
                pos.left += obj.offsetLeft;
               pos.top += obj.offsetTop;
               obj = obj.offsetParent;    
               }
                   return pos;                   
             }
               var p = getPos( oDiv3 );
               alert( p.top );
</code></pre><p>8.宽度高度（width height）<br>     style.width : 样式宽<br>     clientWidth : 可视区宽      样式宽 + padding<br>     offsetWidth    : 占位宽<br>     可视区宽 + 边框<br>9.getAttribute                </p>
<p> 元素.getAttribute(属性名称); 方法 获取指定元素的指定属性的值</p>
<pre><code>alert( oText.getAttribute(&apos;value&apos;) );
</code></pre><p>10.setAttribute               </p>
<p> 元素.setAttribute(属性名称，属性值); 方法 给指定元素指定的属性设置值</p>
<pre><code>oText.setAttribute( &apos;value&apos;, &apos;hello&apos; );
</code></pre><p>11.removeAttribute             </p>
<p> 元素.removeAttribute(属性名称); 方法 移除指定的元素的指定的属性</p>
<pre><code>oText.removeAttribute( &apos;value&apos; );
</code></pre><p>用.和[]的形式无法操作元素的自定义属性</p>
<p> getAttribute可以操作元素的自定义属性</p>
<pre><code>alert( oImg.src );
alert( oImg[&apos;src&apos;] );
</code></pre><p>可以获取元素属性实际的值</p>
<p>ie7下还是会返回资源的绝对路径</p>
<p>12.createElement                </p>
<pre><code>document.createElement(标签名称);   创建元素
var oLi = document.createElement(&apos;li&apos;)
</code></pre><p>13.removeChild                  </p>
<p>父级.removeChild(要删除的元素);     删除元素      oUl.removeChild( this.parentNode );</p>
<p>14.appendChild                  </p>
<p>父级.appendChild(要添加的元素) 方法 追加子元素    oUl.appendChild( oLi );</p>
<p>15.insertBefore                 </p>
<p>父级.insertBefore(新的元素，被插的元素) 方法 在指定元素前面插入一个新元素            </p>
<p> 在ie下如果第二个参数的节点不存在，会报错</p>
<p> 在其他标准浏览器下如果第二个参数的节点不存在，则会以appendChild的形式进行添加</p>
<pre><code>if ( oUl.children[0] ) {
oUl.insertBefore( oLi, oUl.children[0] );
} else {
oUl.appendChild( oLi );            
}
</code></pre><p>16.replaceChild(剪切粘贴的效果) </p>
<p>  父级.replaceChild(新节点，被替换节点) 替换子节点</p>
<p>剪切粘贴的效果    appendChild,insertBefore,replaceChild都可以操作动态创建出来的节点，也可以操作已有节点</p>
<p>17.获取表单中一个元素  表单.元素name   在表单里，name属性比id更好用，独一无二                               </p>
<pre><code>&lt;form id=&quot;form1&quot;&gt; 
&lt;input type=&quot;text&quot; id=&quot;text1&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;     
&lt;/form&gt;

alert( oForm.username.value );
</code></pre><p>18.一组的单选钮，name值设置一致<br>     <input type="radio" name="sex" value="男">男<br>     <input type="radio" name="sex" value="女">女</p>
<p>   一组的复选框，name值设置一致<br>    <input type="checkbox" name="aihao" value="电影">电影<br>    <input type="checkbox" name="aihao" value="音乐">音乐<br>    <input type="checkbox" name="aihao" value="体育">体育</p>
<p>19.onchange : 当值发生改变的时候触发   type=”text” : 当光标离开元素的时候再去判断值是否发生了变化，如果发生了变化则触发onchange事件</p>
<p>20.onsubmit : 当表单被提交的时候触发    阻止触发  return false;</p>
<p>   onreset : 当表单要重置的时候触发</p>
<p>   return confirm(‘你确定要重置？’);</p>
<p>21.表格的动态添加 ！！！！</p>
<pre><code>tHead（一个）   tBodies（多个）  tFoot（一个）  rows  cells
 表格头           表格正文        表格尾         行     列

 alert( oTab.tBodies[0].rows[1].cells[1].innerHTML);
</code></pre><h2 id="BOM知识-Browser-Object-Model-浏览器对象模型"><a href="#BOM知识-Browser-Object-Model-浏览器对象模型" class="headerlink" title="BOM知识   Browser Object Model 浏览器对象模型"></a>BOM知识   Browser Object Model 浏览器对象模型</h2><ol>
<li><p>window.open();   open(地址默认是空白页面，打开方式默认新窗口) 打开一个新窗口    window.open(‘<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">http://www.baidu.com&#39;</a>, ‘_self’);</p>
<pre><code>opener = window.open();//返回值 返回的新开页面的window对象
</code></pre><p>window.close();   ff : 无法关闭    chrome : 直接关闭   ie : 询问用户</p>
</li>
</ol>
<p>2.window.navigator.userAgent : 浏览器信息     alert( window.navigator.userAgent );</p>
<p>3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = window.location内容</span><br><span class="line"></span><br><span class="line">window.location.search = url?后面的内容</span><br><span class="line"></span><br><span class="line">window.location.hash = url#后面的内容</span><br></pre></td></tr></table></figure>
<p>4.可视区尺寸   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert( document.documentElement.clientHeight );</span><br></pre></td></tr></table></figure>
<p>  滚动距离 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;	</span><br><span class="line">alert(scrollTop);</span><br></pre></td></tr></table></figure>
<p>5.onscroll : 当滚动条滚动的时候触发</p>
<p>  onresize : 当窗口大小发生变化的时候触发</p>
<h3 id="事件！！！！！"><a href="#事件！！！！！" class="headerlink" title="事件！！！！！"></a>事件！！！！！</h3><p>1.焦点：使浏览器能够区分用户输入的对象，当一个元素有焦点的时候，那么他就可以接收用户的输入</p>
<p>我们可以通过一些方式给元素设置焦点  1.点击  2.tab  3.js</p>
<p>不是所有元素都能够获得焦点，能够响应用户操作的元素才有焦点 </p>
<pre><code>window.onload=function(){
 var oText=document.getElementById(text1);
   oText.onfocus=function(){
      if(this.value==&apos;请输入内容&apos;)；
         this.value=&apos;&apos;;
         }
    oText.onblur=function(){
      if(this.value==&apos;&apos;)；
         this.value=&apos;请输入内容&apos;;
   }
 }

 &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot; id=&quot;text1&quot;&gt;
</code></pre><p>js实现自动获取焦点：  obj.focus();</p>
<p>js 取消指定元素焦点   obj.blur();</p>
<p>选择指定元素里面的文本内容   obj.select();       设置一个全选按钮，点击后对象里的东西全选</p>
<p>2.event :当一个事件发生的时，和当前这个对象发生的这个事件有关的一些详细信息都会被临时保存到一个指定的地方-event对象，供我们在需要的时候调用</p>
<p> onmousemove ：当鼠标在一个元素上面移动的触发</p>
<p>3.事件冒泡（√√合理利用 能省去大量代码） : 当一个元素接收到事件的时候，会把他接收到的所有传播给他的父级，一直到顶层window.事件冒泡机制</p>
<p>4.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.onclick = fn1;</span><br><span class="line"></span><br><span class="line">document.onclick = fn2;	//会覆盖前面绑定fn1</span><br></pre></td></tr></table></figure>
<p>解决方法：  给一个对象的同一个事件绑定多个不同的函数</p>
<pre><code>function bind(obj, evname, fn) {
if (obj.addEventListener) {
obj.addEventListener(evname, fn, false);
} else {
obj.attachEvent(&apos;on&apos; + evname, function() {
fn.call(obj);
});
}
}

bind(document, &apos;click&apos;, fn1);
</code></pre><p>ie：obj.attachEvent(事件名称，事件函数);<br>    1.没有捕获<br>    2.事件名称有on<br>    3.事件函数执行的顺序：标准ie-》正序   非标准ie-》倒序<br>    4.this指向window<br>标准：obj.addEventListener(事件名称，事件函数，是否捕获);<br>    1.有捕获<br>    2.事件名称没有on<br>    3.事件执行的顺序是正序<br>    4.this触发该事件的对象</p>
<pre><code>是否捕获 : 默认是false    false:冒泡 true：捕获


   document.attachEvent(&apos;onclick&apos;, fn2);
   document.addEventListener(&apos;click&apos;, fn2, false);
   document.attachEvent(&apos;onclick&apos;, function() {
        fn1.call(document);   // fn.call()可以改变this的指向，在attachEvent下指向window
  });
  fn1() == fn1.call();
   call 函数下的一个方法，call方法第一个参数可以改变函数执行过程中的内部this的指向，call方法第二个参数开始就是原来函数的参数列表
   fn1.call(null)指向原来指向的对象，
</code></pre><ol>
<li><p>告诉div1，如果有一个出去的事件触发了你，你就去执行fn1这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oDiv1.addEventListener(&apos;click&apos;, fn1, false);</span><br></pre></td></tr></table></figure>
<p>告诉div1，如果有一个进去的事件触发了你，你就去执行fn1这个函数</p>
</li>
</ol>
<pre><code>oDiv1.addEventListener(&apos;click&apos;, fn1, true);
oDiv1.addEventListener(&apos;click&apos;, function() {
    alert(1);
}, false);
oDiv1.addEventListener(&apos;click&apos;, function() {
    alert(3);
}, true);
oDiv3.addEventListener(&apos;click&apos;, function() {
    alert(2);
}, false);   //  3   2   1   点击事件后从外到里依次排查
</code></pre><ol>
<li>事件函数的取消   obj.onclick=null;也可以取消</li>
</ol>
<pre><code>ie : obj.detachEvent(事件名称，事件函数);
标准 : obj.removeEventListener(事件名称，事件函数，是否捕获);
document.detachEvent(&apos;onclick&apos;, fn1);
document.removeEventListener(&apos;click&apos;, fn1, false);  
</code></pre><ol>
<li><p>onkeydown : 当键盘按键按下的时候触发<br>onkeyup : 当键盘按键抬起的时候触发</p>
<p>event.keyCode : 数字类型 键盘按键的值 键值<br>ctrlKey,shiftKey,altKey 布尔值<br>当一个事件发生的时候，如果ctrl || shift || alt 是按下的状态，返回true，否则返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.onkeydown = function(ev) &#123; </span><br><span class="line">     var ev = ev || event;</span><br><span class="line">     (√)alert(ev.keyCode);   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>8.键盘事件    不是所有元素都能够接收键盘事件，能够响应用户输入的元素，能够接收焦点的元素就能够接收键盘事件</p>
<pre><code>onkeydown : 如果按下不抬起，那么会连续触发
  document.onkeydown = function(ev) {
  var ev = ev || event;
  switch(ev.keyCode) {
        case 37:
            oDiv.style.left = oDiv.offsetLeft - 10 + &apos;px&apos;;   //左移键
            break;
        case 38:
            oDiv.style.top = oDiv.offsetTop - 10 + &apos;px&apos;;    //上移键
            break;
        case 39:
            oDiv.style.left = oDiv.offsetLeft + 10 + &apos;px&apos;;   //右移键
            break;
        case 40:
            oDiv.style.top = oDiv.offsetTop + 10 + &apos;px&apos;;    //下移键
            break;
    }
}
</code></pre><ol>
<li><p>事件默认行为：当一个事件发生的时候浏览器自己会默认做的事情</p>
<p>怎么阻止？  当前这个行为是什么事件触发的，然后在这个事件的处理函数中使用return false;</p>
<p>oncontextmenu:  右键菜单事件，当右键菜单（环境菜单）显示出来的时候触发</p>
<p> document.oncontextmenu=function(){</p>
<pre><code>return false;
</code></pre><p> }    //右击菜单不显示  用一个自己写的div进行代替<br> document.oncontextmenu=function(ev){<br> var ev=ev||event;<br> oDiv.style.display=”block”;<br> oDiv.style.left=ev.clientX+’px’;<br> oDiv.style.top=ev.clientY+’px’;<br> return false;<br> }</p>
</li>
<li>onmousedown : 选择元素<br>onmousemove : 移动元素<br>onmouseup   : 释放元素</li>
</ol>
<ol>
<li><p>aInput[0].setCapture();    //设置全局捕获 ，当我们给一个元素设置全局捕获以后，</p>
<p>那么这个元素就会监听后续发生的所有事件，当有事件发生的时候，</p>
<p>就会被当前设置了全局捕获的元素所触发</p>
</li>
</ol>
<pre><code>/*
ie : 有，并且有效果
ff : 有，但是没效果
chrome : 没有
*/

​
    aInput[0].onclick = function() {
       alert(1);
     }

     aInput[1].onclick = function() {
        alert(2);
     }

     aInput[0].setCapture();   为了解决非IE的默认行为
</code></pre><ol>
<li><p>拖拽的时候，如果有文字被选中，会产生问题</p>
<p> 原因：当鼠标按下的时候，如果页面中有文字被选中，那么会触发浏览器默认拖拽文字的效果</p>
<p> 解决：<br>   标准：阻止默认行为     在最后加上return false;<br>   非标准ie：全局捕获     obj.setCapture();<br>拖拽图片会有问题，原因，解决的办法同上</p>
<p>释放全局捕获 releaseCapture();   在onmousedown下进行全局捕获   在onmouseup下进行释放</p>
</li>
</ol>
<pre><code>设置全局捕获   return false  都是为了解决事件的默认行为      

阻止冒泡： 当前要阻止冒泡的事件函数中调用 event.cancelBubble = true;
</code></pre><p>​        </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/DOM + BOM/" data-id="cjez7tlck0000fwuqjy4mz7us" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/20/JQUERY /" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          jQuery的重点
        
      </div>
    </a>
  
  
    <a href="/2018/03/20/html + css/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">HTML + CSS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/20/Angular/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/20/JQUERY /">jQuery的重点</a>
          </li>
        
          <li>
            <a href="/2018/03/20/DOM + BOM/">DOM + BOM</a>
          </li>
        
          <li>
            <a href="/2018/03/20/html + css/">HTML + CSS</a>
          </li>
        
          <li>
            <a href="/2018/03/20/PHP_01.V5.0/">第一天 服务端开发基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>